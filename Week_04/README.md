## 学习笔记
### 动态规划issue
> 64题：怎么确定dp的数组应该开几维呀？dp都是每次题解看懂，但是遇到新题就不会。

> 我觉得是看你的dp数组在这个位置代表的条件决定的。举个例子：1.本题表示在这个位置的回文串最大半径，条件就是这个位置，而字符串是一维的，所以dp数组就是一维。2. 如果要表示处于二维数组的某个位置的状态，那就建立二维的dp数组 3.如果对于这个位置有其他的限制条件，则加一维。比如股票问题里dp数组代表这一天可以获得的最大利润，按理说是建立一维数组。但是当我们加入限制条件今天是否处于冻结期后，则加一维。 特殊情况比如当前状态只和上一状态有关时，可以用滚动数字降维优化。（仅仅是分享一下本人近期刷题的感觉，可能有误，欢迎指出讨论，一起进步！）

### 回文子串issue
* 回文(palindrome)的要素：中心与半径
-> 遍历全部中心与半径，时间复杂度O(n2)
-> Manacher法，时间复杂度O(n)
#### Manacher法
1. 预处理：插入#保证所有找到的回文串都是奇数长度
```
let process = '$#' + str_in.split('').join("#") + '#^'
// "abbadcda" -> "$#a#b#b#a#d#c#d#a#^"
```
以i为中心的回文子串半径记为radius，则有此：
```
i			0	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20	21	22
process[i]	$	#	a	#	b	#	b	#	a	#	h	#	o	#	p	#	x	#	p	#	o	#	^
radius[i]	1	1	2	1	2	5	2	1	2	1	2	1	2	1	2	1	6	1	2	1	2	1	1
```
有如下恒等关系：
```
max = idx + radius[idx]
radius[i] = min(radius[j], max - i);
where j = [2*idx - i]
```
为什么要用r[j]和max-i取min来更新？

p[j]（以j为中心的最长回文半径）是已经知道了（因为是从前面扫过来的），
若是p[j]>mx-i，
我们是可以知道以j为中心，以max的对称点到j的距离为半径形成的回文字符串是肯定存在的，
并且id的左边直到mx的对称点与id的右边 直到mx是一一对应的，
不难理解mx是i目前可以更新到的最大回文半径；若p[j]<mx-i，
证明j的回文半径不到mx的对称点到j的距离，再次通过
（id的左边直到mx的对称点与id的右边 直到mx是一一对应的），
不难想到p[i]=p[j]。

取完min就是最大的回文半径吗？显然不是，接下来的暴力往后扫就好了