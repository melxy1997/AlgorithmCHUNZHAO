## 学习笔记
Topic：动态规划
### 动态规划issue
* 状态&转移方程 并不像众人所谓“两步走”说的那么轻松，这俩人必然是 紧密联系在一起【同时设计】出来的
* 如何设计？就是多看前人的智慧成果，积累模式，而不是纯在题干中从头找线索

> 64题：怎么确定dp的数组应该开几维呀？dp都是每次题解看懂，但是遇到新题就不会。

> 看你的dp数组在这个位置代表的条件决定的。举个例子：1.本题表示在这个位置的回文串最大半径，条件就是这个位置，而字符串是一维的，所以dp数组就是一维。2. 如果要表示处于二维数组的某个位置的状态，那就建立二维的dp数组 3.如果对于这个位置有其他的限制条件，则加一维。比如股票问题里dp数组代表这一天可以获得的最大利润，按理说是建立一维数组。但是当我们加入限制条件今天是否处于冻结期后，则加一维。 特殊情况比如当前状态只和上一状态有关时，可以用滚动数字降维优化。（仅仅是分享一下本人近期刷题的感觉，可能有误，欢迎指出讨论，一起进步！）

> 32题：一类较难的dp题，其实就是要弄清楚当前状态与之前有什么联系，同时对if中的约束条件仔细审查

> 常见的忽视点：
> 1.数组是否越界
> 2.数组初始化是否具有通解性
> 3.是否遗漏讨论

### 回文子串issue
* 回文(palindrome)的要素：中心与半径
-> 遍历全部中心与半径，时间复杂度O(n2)
-> Manacher法，时间复杂度O(n)
#### Manacher法
https://segmentfault.com/a/1190000008484167
首先预处理：插入#保证所有找到的回文串都是奇数长度
```
let process = '$#' + str_in.split('').join("#") + '#^'
// "abbadcda" -> "$#a#b#b#a#d#c#d#a#^"
```
以i为中心的回文子串半径记为radius，则有此：
```
i			0	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20	21	22
process[i]	$	#	a	#	b	#	b	#	a	#	h	#	o	#	p	#	x	#	p	#	o	#	^
radius[i]	1	1	2	1	2	5	2	1	2	1	2	1	2	1	2	1	6	1	2	1	2	1	1
```
有如下恒等关系：
```
max = idx + radius[idx]
radius[i] = min(radius[j], max - i);
where j = [2*idx - i]
```
为什么要用r[j]和max-i取min来更新？

p[j]（以j为中心的最长回文半径）是已经知道了（因为是从前面扫过来的），
若是p[j]>mx-i，
我们是可以知道以j为中心，以max的对称点到j的距离为半径形成的回文字符串是肯定存在的，
并且id的左边直到mx的对称点与id的右边 直到mx是一一对应的，
不难理解mx是i目前可以更新到的最大回文半径；若p[j]<mx-i，
证明j的回文半径不到mx的对称点到j的距离，再次通过
（id的左边直到mx的对称点与id的右边 直到mx是一一对应的），
不难想到p[i]=p[j]。

取完min就是最大的回文半径吗？显然不是，接下来的暴力往后扫就好了

### 子矩阵的和issue
363. 矩形区域不超过 K 的最大数值和
最大矩阵 + 560：和为k的子数组  或者是 continue subarray sum
思想都是用一个 set 保存之前的sum，如果当前sum - k 的元素在set当中,说明之前出现过
举个例子 1 4 3 1 2  5 6    k = 8
i从0开始 当 i = 5的时候 sum[i] = 16  set={1,5,8,9,11}
那么16 - 8 = 8 出现在set中 所以 i从3到5的和 等于8 
最大矩阵看https://www.youtube.com/watch?v=yCQN096CwWM&t=430s